# 理解上下文（Context）

> 学习什么是上下文，为什么它很重要，以及如何有效地管理它以从 Claude Code 获得更好的结果。

## 为什么这很重要

想象你在 Claude Code 中讨论营养计划设计。你讨论不同的食物、它们的健康益处、卡路里计数，并一起做出决策。对话跨越 20 多次交换。

然后，在同一个会话中，你问 Claude 一个完全不相关的问题："我如何调试这个 Python 错误？"

你注意到 Claude 的回答感觉……不对劲。不那么详细。不如平常有帮助。这不是因为 Claude 变笨了。这是因为 Claude 的注意力被分散了。

你输入的每一个词，Claude 给出的每一个响应，你引用的每一个文件 — 它们都加起来。在某个时刻，Claude 有这么多信息要处理，以至于真正重要的东西被埋没了。

这就是关于**上下文** — Claude 此刻正在处理的全部信息。

## 什么是上下文？

**上下文**是 Claude 现在能"看到"的一切：

- 你在这次对话中的之前问题
- Claude 之前的答案
- 你要求 Claude 阅读的文件
- 系统提示词（来自斜杠命令）
- 任何你粘贴的文本

把它想象成你大脑的工作记忆。你可以在脑子里保留很多信息，但有一个限制。如果你不断添加更多信息，某些东西会被遗忘。

## 上下文窗口

Claude 有一个**上下文窗口** — 它一次能处理的最大信息量。

把它想象成电脑上的 RAM：
- 大小有限
- 你正在使用的所有东西都占用空间
- 当它满时，性能会下降

Claude 的上下文窗口很大（200,000 tokens），但不是无限的。每次对话都会占用它。

## 什么消耗上下文？

你会话中的一切都计入你的上下文：

```
+--------------------------------------+
| 系统提示词（斜杠命令）               | ~500 tokens
+--------------------------------------+
| 你的第一个问题                       | ~50 tokens
| Claude 的第一个答案                  | ~200 tokens
+--------------------------------------+
| 你的第二个问题                       | ~60 tokens
| Claude 的第二个答案                  | ~180 tokens
+--------------------------------------+
| 你要求 Claude 阅读的文件             | ~1,000 tokens
+--------------------------------------+
| 你的第三个问题                       | ~70 tokens
| Claude 的第三个答案                  | ~220 tokens
+--------------------------------------+
| 总计使用中：~2,280 tokens            |
| 剩余：~197,720 tokens (98%)          |
+--------------------------------------+
```

每次交换都会加起来。小贡献变成大问题。

## 长上下文的问题

### 问题 1：上下文压力和压缩

当你的上下文接近限制时，Claude 会自动压缩历史记录。它试图保留最重要的信息并压缩其余部分。

但这里有个问题：**Claude 不知道什么对你很重要。**

它可能压缩掉你需要的唯一关键细节。结果？Claude 给你不完整的答案，因为它忘记了关键上下文。

### 问题 2：Token 浪费

每次交换都消耗 token。如果你的会话很大，但你的新问题与旧讨论无关，你就在为你没有使用的信息付费。

例子：
- 你花了 10,000 tokens 讨论数据库设计
- 现在你问 CSS 样式问题
- Claude 仍然需要处理数据库讨论中的所有 10,000 tokens
- 成本：~10,000 tokens，用于与你的问题无关的上下文

这就像为了了解一个章节而付钱让某人给你读整本历史书。

## 为什么管理会话很重要

这就是为什么**管理会话**教程很重要。会话让你能够：

- **从头开始** — 新会话 = 干净的上下文
- **保持专注** — 一次对话 = 一个问题
- **需要时恢复** — 使用 `-c` 或 `-r` 在需要旧上下文时返回

会话是你有效管理上下文的工具。

## 解决方案：文档策略

这里的关键洞察：**不要保留上下文 — 提取它。**

与其依赖你的会话历史，不如创建一个文档：

1. 与 Claude 进行一次专注的对话
2. 完成后，要求 Claude 将关键要点总结成一个**精简文档**
3. 将该文档保存到你的项目
4. 在未来的会话中，引用该文档而不是依赖历史

例子：
```
你：根据我们的讨论，我认为关键要点是：
- 低卡路里但好吃的食物
- 简易的准备方法
- 我选择尝试的食物

请创建一个精简 markdown 文档（300-500 字）总结关键建议和我选择的食物。
格式要漂亮，因为我要把它保存为 docs/nutrition-plan.md。

Claude：[生成精简总结 markdown]
```

下一个会话：
```
cat docs/nutrition-plan.md
[继续，上下文干净，没有历史包袱]
```

## 手动上下文压缩如何工作

你可以控制压缩，而不是让 Claude 自动做：

1. **识别什么重要** — 告诉 Claude："我们讨论的哪些部分最重要？"
2. **要求压缩** — "请写一个 200 字的摘要，重点放在[特定方面]"
3. **引用摘要** — 在未来的会话中，只需引用文档

Claude 不需要重新阅读所有内容。它可以阅读压缩版本并保持专注。

## 何时需要长上下文

并非每项任务都需要短上下文。长上下文在以下情况下很有价值：

- **构建复杂系统** — 你需要看到完整的架构
- **一致的叙述** — 故事需要连续性（比如写小说）
- **调试复杂问题** — 你需要看到所有代码交互
- **协作设计** — 多个决策相互依赖

在这些情况下，使用更长的会话。但即便如此，也要考虑：
- 分解为专注的阶段（每个阶段一个会话）
- 维护 `docs/` 文件夹，里面放关键决策
- 定期要求 Claude 总结进度

## 动手练习：创建你的第一个文档

让我们在一个完整的练习中实践文档化策略。

**任务：食物推荐**

1. **启动一个 Claude Code 会话：** `claude`

2. **进行一次随意的对话**（5-8 次交换）：
   - 问：`我想吃得更健康。你能推荐一些低卡路里但好吃的食物吗？我喜欢[你的食物偏好]。`
   - 提出关于营养、味道、准备方法的后续问题
   - 讨论推荐
   - 做出关于尝试哪些食物的决定

3. **要求 Claude 创建文档**（一个完整的提示）：
   ```
   根据我们的讨论，我认为最重要的要点是：
   - 低卡路里但真的好吃的食物
   - 简易的准备方法
   - 我选择尝试的具体食物

   请创建一个精简 markdown 文档（300-500 字）总结：
   1. 我们讨论过的关键食物推荐
   2. 为什么这些食物是好选择
   3. 我选择尝试的具体食物

   格式要漂亮，因为我要把它保存为 docs/my-nutrition-plan.md
   ```

4. **复制 Claude 的响应**并将其保存为项目中的 `docs/my-nutrition-plan.md`

5. **将文档链接发送给你的导师**作为完成练习的证明

   例子："我完成了这个练习。这是我的文档：docs/my-nutrition-plan.md"

**你在练习什么：**
- 进行有意义的对话
- 认识何时将历史转换为文档
- 创建可重用的、上下文高效的文档
- 为新会话做准备（旧上下文消失了，但文档保留下来）

## 快速参考

- **上下文** — Claude 目前正在处理的一切
- **上下文窗口** — 最大容量（~200,000 tokens）
- **上下文压力** — 当上下文满时，Claude 压缩（有丢失信息的风险）
- **会话管理** — 保持对话专注，使用 `-c` 或 `-r` 来切换
- **文档化** — 从对话中提取关键要点到可重用的文档
- **手动压缩** — 要求 Claude 将重要信息压缩成精简摘要

## 导师的话：构建可持续的工作流

在我早期使用 AI 的工作中，我会进行这些冗长、分散的对话。"我会把所有这些放在上下文中，"我想。然后我意识到我不记得我们决定了什么，Claude 也不记得 — 它被埋在 30,000 tokens 的聊天历史中。

我用艰难的方式学到了：**上下文不是记忆。文档才是。**

思维方式的转变：与其问"我如何将这个保留在上下文中？"，不如问"我如何将这个对话中的价值提取成我可以重用的东西？"

这改变了一切：
- 对话变得更加专注
- 我建立了一个有记录的决策知识库
- 新会话很干净很快
- 未来的我可以引用过去的工作而无需重新讨论

我认识的最好的工程师都无情地实践这一点。他们不累积上下文；他们压缩它。他们不依赖记忆；他们系统地记录。

这一个习惯 — 将对话转换为文档 — 将在你使用的每个工具中为你服务，而不仅仅是 Claude Code。

## 进一步阅读

- [Claude 上下文窗口文档](https://docs.anthropic.com/en/docs/about-claude/models/overview)
- [提示工程最佳实践](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering)
